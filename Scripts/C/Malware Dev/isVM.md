# Check if is VM

## C Code

```c
#include <windows.h>
#include <stdio.h>

typedef int (*MyFunctionType)(int, int);

int main() {
    // Cargar la DLL
    HINSTANCE hDLL = LoadLibraryA("IsVM.dll");
    if (!hDLL) {
        printf("No se pudo cargar la DLL\n");
        return 1;
    }

    // Obtener la dirección de la función
    MyFunctionType MyFunction = (MyFunctionType)GetProcAddress(hDLL, "CheckIfVirtualMachine");
    if (!MyFunction) {
        printf("No se pudo encontrar la función MyFunction en la DLL\n");
        FreeLibrary(hDLL);
        return 1;
    }

    // Ejecutar la función
    int result = MyFunction(10, 20);
    printf("El resultado de MyFunction es: %d\n", result);

    // Liberar la DLL
    FreeLibrary(hDLL);

    return 0;
}
```

## DLL Code

```c
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <tlhelp32.h> 
#include <tchar.h>
#include <iphlpapi.h> // Para trabajar con direcciones MAC
#include <intrin.h>   // Para utilizar __cpuid
#pragma comment(lib, "IPHLPAPI.lib") // Necesario para la librería IP Helper API

// Función 1: Verificar si el CPUID indica que estamos en una máquina virtual
BOOL IsVMBasedOnCPUID() {
    int cpuInfo[4] = { 0 };
    __cpuid(cpuInfo, 1);  // CPUID con EAX=1

    // ECX bit 31 indica si hay un hipervisor presente
    if (cpuInfo[2] & (1 << 31)) {
        return TRUE;  // Hipervisor presente, es una VM
    }
    return FALSE;
}

// Función 2: Verificar si la dirección MAC tiene prefijos de VMware o VirtualBox
BOOL IsMACAddressForVM() {
    PIP_ADAPTER_INFO AdapterInfo;
    DWORD dwBufLen = sizeof(AdapterInfo);
    AdapterInfo = (IP_ADAPTER_INFO*)malloc(dwBufLen);

    if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {
        AdapterInfo = (IP_ADAPTER_INFO*)malloc(dwBufLen);
    }

    if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) {
        PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;
        while (pAdapterInfo) {
            BYTE* mac = pAdapterInfo->Address;

            // Revisar los prefijos comunes de MAC de VMware y VirtualBox
            if ((mac[0] == 0x00 && mac[1] == 0x05 && mac[2] == 0x69) ||  // VMware MAC
                (mac[0] == 0x00 && mac[1] == 0x0C && mac[2] == 0x29) ||  // VMware MAC
                (mac[0] == 0x00 && mac[1] == 0x50 && mac[2] == 0x56) ||  // VMware MAC
                (mac[0] == 0x08 && mac[1] == 0x00 && mac[2] == 0x27)) {  // VirtualBox MAC
                free(AdapterInfo);
                return TRUE;
            }
            pAdapterInfo = pAdapterInfo->Next;
        }
    }
    free(AdapterInfo);
    return FALSE;
}

// Función 3: Verificar si se están ejecutando procesos relacionados con Guest Additions
BOOL IsVMSoftwareRunning() {
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (hProcessSnap == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    pe32.dwSize = sizeof(PROCESSENTRY32);
    if (!Process32First(hProcessSnap, &pe32)) {
        CloseHandle(hProcessSnap);
        return FALSE;
    }

    do {
        if (_tcsicmp(pe32.szExeFile, _T("VBoxService.exe")) == 0 ||  // VirtualBox Guest Additions
            _tcsicmp(pe32.szExeFile, _T("vmtoolsd.exe")) == 0 ||    // VMware Tools
            _tcsicmp(pe32.szExeFile, _T("vmwaretray.exe")) == 0) {  // VMware tray process
            CloseHandle(hProcessSnap);
            return TRUE;
        }
    } while (Process32Next(hProcessSnap, &pe32));

    CloseHandle(hProcessSnap);
    return FALSE;
}

// Función exportada: realiza todas las validaciones
//extern "C" __declspec(dllexport) void CheckIfVirtualMachine(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow) {
    extern __declspec(dllexport) void CheckIfVirtualMachine() {
    if (IsVMBasedOnCPUID()) {
        MessageBoxA(NULL, "Es una máquina virtual (verificado por CPUID).", "VM Detection", MB_ICONINFORMATION);
    }
    if (IsMACAddressForVM()) {
        MessageBoxA(NULL, "Es una máquina virtual (verificado por dirección MAC).", "VM Detection", MB_ICONINFORMATION);
    }
    if (IsVMSoftwareRunning()) {
        MessageBoxA(NULL, "Es una máquina virtual (verificado por software de VMware o VirtualBox).", "VM Detection", MB_ICONINFORMATION);
    }
    else {
        MessageBoxA(NULL, "No parece ser una máquina virtual.", "VM Detection", MB_ICONINFORMATION);
    }
}

// Punto de entrada para la DLL
BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```